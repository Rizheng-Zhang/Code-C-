### 题目描述

![图片](https://user-images.githubusercontent.com/113157460/192130464-e7784e7c-b870-4041-a3c3-6f50df7cf634.png)

上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。

路径上的每一步只能从一个数走到下一层和它最近的左边的那个数或者右 边的那个数。`此外，向左下走的次数与向右下走的次数相差不能超过 1。`

### 输入描述

输入的第一行包含一个整数 N (1≤N≤100)，表示三角形的行数。

下面的 N 行给出数字三角形。数字三角形上的数都是 0 至 100 之间的整数。

### 输出描述

输出一个整数，表示答案。

### 输入输出样例
**输入**

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

**输出**
```
27
```

### code
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int f[N][N],w[N][N];//自顶向下，DP，f[i][j]表示从顶点到（i，j）这个点的路径最大和
int n;
int main(){
  cin>>n;
  for(int i=1;i<=n;i++){
    for(int j=1;j<=i;j++){
      cin>>w[i][j];//赋值
    }
  }
  f[1][1]=w[1][1];//第一行赋初值
  for(int i=2;i<=n;i++){
    for(int j=1;j<=i;j++){
      f[i][j]=max(f[i-1][j-1]+w[i][j],f[i-1][j]+w[i][j]);//从第2行开始，最大值等于上一层从左走或从右走最大的那个
    }
  }
  if(n%2==0) cout<<max(f[n][n/2],f[n][n/2+1]);//向左下走的次数与向右下走的次数相差不能超过 1
  else cout<<f[n][n/2+1];//分析发现，当n为偶数时，最后只能落在中间两个点中的一个，奇数为中间那一个点
  return 0;
}
```
